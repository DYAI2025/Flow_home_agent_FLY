<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LiveKit Agent Avatar Cockpit</title>
    <style>
      :root {
        --bg: #0d1117;
        --panel: #161b22;
        --panel-border: #30363d;
        --accent: #58a6ff;
        --text: #f0f6fc;
        --muted: #8b949e;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
        background: radial-gradient(circle at top left, rgba(88, 166, 255, 0.2), transparent 55%),
          radial-gradient(circle at bottom right, rgba(56, 139, 253, 0.15), transparent 50%),
          var(--bg);
        color: var(--text);
      }

      header {
        padding: 1.5rem 2rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid var(--panel-border);
        backdrop-filter: blur(8px);
      }

      header h1 {
        margin: 0;
        font-size: 1.5rem;
      }

      .container {
        display: grid;
        gap: 1.5rem;
        padding: 1.5rem 2rem 3rem;
        grid-template-columns: minmax(0, 2fr) minmax(0, 1fr);
      }

      .panel {
        background: var(--panel);
        border: 1px solid var(--panel-border);
        border-radius: 16px;
        padding: 1.5rem;
        box-shadow: 0 18px 30px rgba(2, 6, 23, 0.3);
      }

      .video-stage {
        position: relative;
        height: 420px;
        border-radius: 12px;
        overflow: hidden;
        border: 1px solid rgba(88, 166, 255, 0.25);
        background: linear-gradient(145deg, rgba(88, 166, 255, 0.12), rgba(22, 27, 34, 0.5));
        display: flex;
        align-items: center;
        justify-content: center;
      }

      video {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .placeholder {
        text-align: center;
        color: var(--muted);
      }

      .placeholder span {
        display: block;
        font-size: 3rem;
        margin-bottom: 0.5rem;
      }

      .controls {
        display: grid;
        gap: 1rem;
      }

      .controls-row {
        display: grid;
        gap: 0.75rem;
      }

      .controls-row.with-buttons {
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      }

      label {
        font-size: 0.85rem;
        color: var(--muted);
        display: block;
        margin-bottom: 0.35rem;
      }

      input,
      select,
      button {
        width: 100%;
        padding: 0.75rem 0.85rem;
        border-radius: 10px;
        border: 1px solid var(--panel-border);
        background: #0e131b;
        color: var(--text);
      }

      button {
        background: linear-gradient(135deg, rgba(88, 166, 255, 0.2), rgba(88, 166, 255, 0.05));
        border-color: rgba(88, 166, 255, 0.4);
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      button:hover {
        transform: translateY(-1px);
        box-shadow: 0 8px 20px rgba(88, 166, 255, 0.25);
      }

      .config-output {
        display: flex;
        align-items: center;
        padding: 0.75rem 0.85rem;
        border-radius: 10px;
        border: 1px dashed var(--panel-border);
        background: rgba(14, 19, 27, 0.75);
        color: var(--muted);
        font-family: 'IBM Plex Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          'Liberation Mono', 'Courier New', monospace;
        font-size: 0.85rem;
        min-height: 2.6rem;
        word-break: break-all;
      }

      .config-output.configured {
        border-style: solid;
        color: var(--accent);
      }

      .status {
        padding: 0.75rem 1rem;
        border-radius: 10px;
        background: rgba(88, 166, 255, 0.08);
        border: 1px solid rgba(88, 166, 255, 0.2);
        color: var(--accent);
        font-size: 0.95rem;
      }

      .chat-container {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .messages {
        border-radius: 12px;
        border: 1px solid var(--panel-border);
        background: rgba(13, 17, 23, 0.6);
        height: 240px;
        overflow-y: auto;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .message {
        padding: 0.65rem 0.75rem;
        border-radius: 10px;
        font-size: 0.95rem;
        line-height: 1.5;
      }

      .message.system {
        background: rgba(56, 139, 253, 0.12);
        color: var(--accent);
      }

      .message.user {
        background: rgba(88, 166, 255, 0.18);
        align-self: flex-end;
      }

      .message.agent {
        background: rgba(19, 176, 110, 0.15);
        align-self: flex-start;
      }

      .input-row {
        display: grid;
        grid-template-columns: minmax(0, 1fr) auto;
        gap: 0.75rem;
      }

      @media (max-width: 980px) {
        .container {
          grid-template-columns: 1fr;
        }

        header {
          flex-direction: column;
          gap: 0.75rem;
          align-items: flex-start;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>LiveKit Agent Avatar Cockpit</h1>
      <p class="chip">Connect, stream and collaborate in real-time</p>
    </header>

    <main class="container">
      <section class="panel">
        <div class="video-stage" id="avatarStage">
          <div class="placeholder" id="videoPlaceholder">
            <span>ðŸ¤–</span>
            <strong>Avatar stream waitingâ€¦</strong>
            <small>Connect to a room to start streaming</small>
          </div>
          <video id="remoteVideo" autoplay playsinline style="display: none"></video>
          <video id="localVideo" autoplay muted playsinline style="display: none"></video>
        </div>

        <div class="controls" style="margin-top: 1.5rem">
          <div class="controls-row">
            <label for="roomInput">Room name</label>
            <input id="roomInput" placeholder="e.g. avatar-room" />
          </div>
          <div class="controls-row">
            <label for="identityInput">Your identity</label>
            <input id="identityInput" placeholder="e.g. user" />
          </div>
          <div class="controls-row with-buttons">
            <button id="connectBtn">Connect</button>
            <button id="disconnectBtn" disabled>Disconnect</button>
            <button id="refreshAvatarBtn" disabled>Refresh Cartesia Avatar</button>
          </div>
          <div class="controls-row">
            <label>Cartesia voice ID</label>
            <div class="config-output" id="cartesiaVoiceId">Loadingâ€¦</div>
          </div>
          <div class="controls-row">
            <label>Cartesia face ID</label>
            <div class="config-output" id="cartesiaFaceId">Loadingâ€¦</div>
          </div>
          <div class="status" id="status">Status: Not connected</div>
        </div>
      </section>

      <aside class="panel chat-container">
        <h2 style="margin-top: 0">Conversation</h2>
        <div class="messages" id="chatMessages"></div>
        <div class="input-row">
          <input id="messageInput" placeholder="Send a messageâ€¦" />
          <button id="sendBtn">Send</button>
        </div>
      </aside>
    </main>

    <script>
      async function loadLiveKit() {
        if (window.LiveKit) {
          return window.LiveKit;
        }

        const loadScript = (src) =>
          new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.async = true;
            script.onload = () => resolve();
            script.onerror = () => reject(new Error(`Failed to load script ${src}`));
            document.head.appendChild(script);
          });

        const cdnSrc = 'https://unpkg.com/livekit-client@1.15.7/dist/livekit-client.min.js';
        try {
          await loadScript(cdnSrc);
        } catch (cdnError) {
          console.warn('Failed to load LiveKit from CDN, trying local fallback.', cdnError);
        }

        if (!window.LiveKit) {
          try {
            await loadScript('libs/livekit-client.umd.js');
          } catch (localError) {
            throw new Error('Unable to load LiveKit SDK from CDN or local fallback.');
          }
        }

        if (!window.LiveKit) {
          throw new Error('LiveKit SDK failed to initialize.');
        }

        return window.LiveKit;
      }

      function initApp(LiveKit) {
        const statusEl = document.getElementById('status');
        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const sendBtn = document.getElementById('sendBtn');
        const remoteVideo = document.getElementById('remoteVideo');
        const localVideo = document.getElementById('localVideo');
        const videoPlaceholder = document.getElementById('videoPlaceholder');
        const avatarStage = document.getElementById('avatarStage');
        const refreshAvatarBtn = document.getElementById('refreshAvatarBtn');
        const voiceIdDisplay = document.getElementById('cartesiaVoiceId');
        const faceIdDisplay = document.getElementById('cartesiaFaceId');

        const dataPacketKind = LiveKit.DataPacket_Kind ?? LiveKit.DataPacketKind;
        const DEFAULT_RELIABLE_KIND = 0;
        const reliableDataKind = dataPacketKind?.RELIABLE ?? DEFAULT_RELIABLE_KIND;
        if (!dataPacketKind) {
          console.warn(`LiveKit DataPacket kind enum missing; defaulting RELIABLE data kind to ${DEFAULT_RELIABLE_KIND}.`);
        }
        let room = null;
        let cartesiaConfig = { voiceConfigured: false, faceConfigured: false };
        let avatarObjectUrl = null;

        function addMessage(type, text) {
          const wrapper = document.createElement('div');
          wrapper.className = `message ${type}`;
          const timestamp = new Date().toLocaleTimeString();
          wrapper.textContent = `[${timestamp}] ${text}`;
          chatMessages.appendChild(wrapper);
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function setStatus(text) {
          statusEl.textContent = `Status: ${text}`;
        }

        function renderConfigValue(element, value, configured = Boolean(value)) {
          if (!element) return;
          if (value) {
            element.textContent = value;
            element.classList.toggle('configured', configured);
          } else {
            element.textContent = 'Not configured';
            element.classList.remove('configured');
          }
        }

        function updateAvatarButtonState(forceDisable = false) {
          if (!refreshAvatarBtn) return;
          refreshAvatarBtn.disabled = forceDisable || !cartesiaConfig?.faceConfigured;
        }

        function clearAvatarImage() {
          if (avatarObjectUrl) {
            URL.revokeObjectURL(avatarObjectUrl);
            avatarObjectUrl = null;
          }
          avatarStage.style.backgroundImage = 'none';
          avatarStage.style.backgroundSize = '';
          avatarStage.style.backgroundPosition = '';
        }

        function updatePlaceholderVisibility() {
          if (remoteVideo.style.display !== 'none') {
            videoPlaceholder.style.display = 'none';
            return;
          }
          videoPlaceholder.style.display = avatarObjectUrl ? 'none' : 'flex';
        }

        function detachLocalTracks() {
          if (!room) return;
          room.localParticipant
            .getTrackPublications()
            .forEach((publication) => {
              if (publication.track) {
                publication.track.detach();
                publication.track.stop();
              }
            });
        }

        async function refreshCartesiaAvatar() {
          if (!cartesiaConfig?.faceConfigured) {
            addMessage('system', 'Cartesia face ID is not available. Check the server configuration.');
            updateAvatarButtonState();
            return;
          }

          if (!refreshAvatarBtn) return;

          const previousLabel = refreshAvatarBtn.textContent;
          refreshAvatarBtn.textContent = 'Refreshingâ€¦';
          refreshAvatarBtn.disabled = true;

          try {
            const response = await fetch('/cartesia/avatar', { cache: 'no-store' });
            if (!response.ok) {
              let errorMessage = 'Failed to load Cartesia avatar.';
              try {
                const payload = await response.json();
                if (payload?.error) {
                  errorMessage = payload.error;
                }
              } catch (parseError) {
                console.warn('Non-JSON Cartesia avatar response', parseError);
              }
              throw new Error(errorMessage);
            }

            const blob = await response.blob();
            clearAvatarImage();
            avatarObjectUrl = URL.createObjectURL(blob);
            avatarStage.style.backgroundImage = `url('${avatarObjectUrl}')`;
            avatarStage.style.backgroundSize = 'cover';
            avatarStage.style.backgroundPosition = 'center';
            updatePlaceholderVisibility();
            addMessage('system', 'Cartesia avatar refreshed.');
          } catch (error) {
            console.error('Unable to refresh Cartesia avatar', error);
            clearAvatarImage();
            updatePlaceholderVisibility();
            addMessage('system', `Cartesia avatar error: ${error.message}`);
          } finally {
            refreshAvatarBtn.textContent = previousLabel;
            updateAvatarButtonState();
          }
        }

        async function loadCartesiaConfig() {
          if (voiceIdDisplay) voiceIdDisplay.textContent = 'Loadingâ€¦';
          if (faceIdDisplay) faceIdDisplay.textContent = 'Loadingâ€¦';

          try {
            const response = await fetch('/cartesia/config', { cache: 'no-store' });
            if (!response.ok) {
              throw new Error('Cartesia configuration unavailable');
            }

            const config = await response.json();
            cartesiaConfig = config;
            renderConfigValue(voiceIdDisplay, config.voiceId, config.voiceConfigured);
            renderConfigValue(faceIdDisplay, config.faceId, config.faceConfigured);
            updateAvatarButtonState();

            if (config.faceConfigured) {
              addMessage('system', 'Cartesia face configuration detected.');
              await refreshCartesiaAvatar();
            } else {
              clearAvatarImage();
              updatePlaceholderVisibility();
              addMessage('system', 'Cartesia face ID is not configured.');
            }

            if (config.voiceConfigured) {
              addMessage('system', 'Cartesia voice ID loaded.');
            }
          } catch (error) {
            console.error('Unable to load Cartesia configuration', error);
            cartesiaConfig = { voiceConfigured: false, faceConfigured: false };
            renderConfigValue(voiceIdDisplay, null, false);
            renderConfigValue(faceIdDisplay, null, false);
            clearAvatarImage();
            updatePlaceholderVisibility();
            updateAvatarButtonState(true);
            addMessage('system', 'Unable to load Cartesia configuration from the server.');
          }
        }

        async function connect() {
          const { Room, RoomEvent } = LiveKit;
          if (!Room || !RoomEvent) {
            const message = 'LiveKit SDK is not ready. Please refresh and try again.';
            setStatus(`Error: ${message}`);
            addMessage('system', message);
            return;
          }

          const roomName = document.getElementById('roomInput').value.trim() || 'avatar-room';
          const identity = document.getElementById('identityInput').value.trim() || 'user';

          setStatus(`Requesting access token for ${roomName}â€¦`);

          try {
            const response = await fetch(`/token?room=${encodeURIComponent(roomName)}&identity=${encodeURIComponent(identity)}`);

            if (!response.ok) {
              const payload = await response.json().catch(() => ({}));
              throw new Error(payload.error || 'Token request failed');
            }

            const { token, url } = await response.json();

            room = new Room({ adaptiveStream: true });

            room.on(RoomEvent.TrackSubscribed, (track) => {
              if (track.kind === 'video') {
                track.attach(remoteVideo);
                remoteVideo.style.display = 'block';
                updatePlaceholderVisibility();
              }
            });

            room.on(RoomEvent.TrackUnsubscribed, (track) => {
              if (track.kind === 'video') {
                track.detach();
                remoteVideo.style.display = 'none';
                updatePlaceholderVisibility();
              }
            });

            room.on(RoomEvent.DataReceived, (payload, participant) => {
              const text = new TextDecoder().decode(payload);
              addMessage('agent', `${participant.identity}: ${text}`);
            });

            room.on(RoomEvent.Disconnected, () => {
              detachLocalTracks();
              disconnect(true);
            });

            await room.connect(url, token);
            setStatus(`Connected to ${roomName}`);
            addMessage('system', `Connected as ${identity}`);

            connectBtn.disabled = true;
            disconnectBtn.disabled = false;
            sendBtn.disabled = false;

            try {
              const publications = await room.localParticipant.enableCameraAndMicrophone();
              let publishedVideo = false;
              publications.forEach((publication) => {
                if (publication.track && publication.track.kind === 'video') {
                  publication.track.attach(localVideo);
                  localVideo.style.display = 'block';
                  publishedVideo = true;
                }
              });
              if (!publishedVideo) {
                addMessage('system', 'Connected without publishing a local video track.');
              }
            } catch (mediaError) {
              console.warn('Unable to enable local media', mediaError);
              addMessage('system', 'Connected but could not access camera or microphone.');
            }

            // Removed duplicate sendBtn.onclick assignment; rely on addEventListener outside connect.
          } catch (error) {
            console.error('Failed to connect', error);
            setStatus(`Error: ${error.message}`);
            addMessage('system', `Connection failed: ${error.message}`);
            disconnect(true);
          }
        }

        function disconnect(silent = false) {
          if (room) {
            detachLocalTracks();
            room.disconnect();
            room = null;
          }

          connectBtn.disabled = false;
          disconnectBtn.disabled = true;
          sendBtn.disabled = true;
          remoteVideo.style.display = 'none';
          localVideo.style.display = 'none';
          updatePlaceholderVisibility();
          setStatus('Not connected');

          if (!silent) {
            addMessage('system', 'Disconnected');
          }
        }

        function sendMessage(kind = reliableDataKind) {
          const text = messageInput.value.trim();
          if (!text || !room) return;

          const payload = new TextEncoder().encode(text);
          const dataKind = typeof kind === 'number' ? kind : reliableDataKind;
          room.localParticipant.publishData(payload, dataKind);
          addMessage('user', text);
          messageInput.value = '';
        }

        connectBtn.addEventListener('click', connect);
        disconnectBtn.addEventListener('click', () => disconnect(false));
        sendBtn.addEventListener('click', () => sendMessage(reliableDataKind));
        if (refreshAvatarBtn) {
          refreshAvatarBtn.addEventListener('click', () => {
            refreshCartesiaAvatar();
          });
        }
        messageInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            sendMessage(reliableDataKind);
          }
        });

        addMessage('system', 'Welcome! Configure a room and press Connect to begin.');
        addMessage('system', 'Fetching Cartesia configuration from the serverâ€¦');
        sendBtn.disabled = true;
        loadCartesiaConfig();
        window.addEventListener('beforeunload', () => disconnect(true));
      }

      loadLiveKit()
        .then((LiveKit) => {
          initApp(LiveKit);
        })
        .catch((error) => {
          console.error('LiveKit library failed to load', error);
          const status = document.getElementById('status');
          if (status) {
            status.textContent = `Error: ${error.message}`;
          }
        });
    </script>
  </body>
</html>
